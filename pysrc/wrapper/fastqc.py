# !/usr/bin/env python
# -*- coding:utf-8 -*-
# author : zerodel
# Readme:
#

import os
import io
import copy

import zipfile

import pysrc.body.worker
import pysrc.body.logger
import pysrc.body.cli_opts
import pysrc.body.option_check

STR_MODULE_START = ">>"
STR_MODULE_END = ">>END_MODULE"

__doc__ = '''
'''

__author__ = 'zerodel'

_logger = pysrc.body.logger.default_logger(logger_name="FASTQC_LOG")

SECTION_QC_SETTING = 'FASTQC'


def _prepare_opt_checker(args_dict=None):
    fastqc_opt_checker = pysrc.body.option_check.OptionChecker(args_dict, name="fastqc_check_opt", logger=_logger)

    fastqc_opt_checker.forbid_these_args("-h", "--help", "-v", "--version")

    fastqc_opt_checker.at_most_one(["-o", "--outdir"], pysrc.body.option_check.this_abs_path_should_be_a_dir,
                                   FileExistsError("this path should be a directory"),
                                   "where to put the result of fastqc")

    fastqc_opt_checker.at_most_one(["-a", "--adapters"], os.path.isfile, FileNotFoundError("this path should be a "
                                                                                           "info file for adapter"),
                                   "Specifies a non-default file which contains the list of adapter sequences")

    fastqc_opt_checker.must_have("seqs", pysrc.body.option_check.all_files_in_this_string_should_exist,
                                 FileNotFoundError("some file did not exist"),
                                 "sequence files that you want to check")
    return fastqc_opt_checker


def _combine_qc_cmd(opts_raw, bin_fastqc="fastqc"):
    opts = copy.copy(opts_raw)
    seqs_str = " ".join(opts.pop("seqs").strip().split())
    cmd_mid = pysrc.body.cli_opts.enum_all_opts(opts)
    return " ".join([bin_fastqc, cmd_mid, seqs_str])


opt_checker = _prepare_opt_checker()
OPTION_CHECKERS = [opt_checker]


def run_qc(par_dict=None, **kwargs):
    opt_qc_raw = pysrc.body.cli_opts.merge_parameters(kwargs, par_dict, SECTION_QC_SETTING)

    opt_checker.check(copy.copy(opt_qc_raw))

    cmd_qc = _combine_qc_cmd(opt_qc_raw)

    _logger.debug("raw command for fastqc is %s" % cmd_qc)

    pysrc.body.worker.run(cmd_qc)

    return opt_qc_raw


def __extract_qc_output_form_opt(opts):
    if "-o" in opts:
        return opts["-o"]
    elif "--outdir" in opts:
        return opts["--outdir"]
    else:
        return ""


def parse_qc_results(par_dict=None, **kwargs):
    opt_qc_raw = pysrc.body.cli_opts.merge_parameters(kwargs, par_dict, SECTION_QC_SETTING)
    dir_qc_output = __extract_qc_output_form_opt(opt_qc_raw)
    if not os.listdir(dir_qc_output):  # empty directory , run qc first .
        _logger.info("no fastqc result under {this_folder}, run fastqc".format(this_folder=dir_qc_output))

        run_qc(par_dict=opt_qc_raw)

    zips_result = [os.path.join(dir_qc_output, x) for x in os.listdir(dir_qc_output) if
                   os.path.splitext(x)[-1] == '.zip']

    if zips_result:
        for result in zips_result:
            res_single_fq = parse_single_fastqc_zip(result)  # do parse for each file
            # todo: what to do after parsing the result of fastqc?
    else:
        # means no result
        _logger.warning("still no zip files under %s" % dir_qc_output)


def parse_single_fastqc_zip(path_to_zip_file):
    """
    interpret zip file generated by fastqc . 
    :param path_to_zip_file: path to a fastqc result .zip file 
    :return: an ObjFastQC object 
    """

    def __determine_fastq_txt_path(where_zip):
        legit_report_txt_path = "{this_zip}/fastqc_data.txt".format(this_zip=(
            os.path.splitext(os.path.basename(where_zip))[0]))
        return legit_report_txt_path

    with zipfile.ZipFile(path_to_zip_file) as obj_zip:
        text_report_this_qc = __determine_fastq_txt_path(path_to_zip_file)
        with obj_zip.open(text_report_this_qc) as txt_modules:
            str_content_fastqc_report = txt_modules.read().decode()

        obj_fastqc = ObjFastQC()
        obj_fastqc.translate_from_str_or_bytes(str_content_fastqc_report)

        return obj_fastqc


def _read_from(look_like_a_file):
    """
    read all content from a file-like object. 
    this object can be a path to a file, or a opened file object in python.
    :param look_like_a_file: a string or a file object
    :return: all content in the input parameter
    """
    if isinstance(look_like_a_file, io.TextIOWrapper):
        txt_handler = look_like_a_file
    elif isinstance(look_like_a_file, str):
        if not os.path.exists(look_like_a_file):
            raise FileNotFoundError("no such file as {}".format(look_like_a_file))
        else:
            try:
                txt_handler = open(look_like_a_file)
            except:
                raise IOError("unable to open this file at : {}".format(look_like_a_file))

    else:
        raise TypeError("encounter a wrong object type: {}".format(type(look_like_a_file)))

    content = txt_handler.read()
    txt_handler.close()
    return content


class ModuleFastQC(object):
    """ represent a module in fastqc result. 
    it describe a single test of fastqc , read quality , adapter information etc.
    
    name: name of test
    result: whether the sample passed the test
    raw_lines: additional text information
    """

    def __init__(self):
        self.name = ""
        self.result = ""
        self.raw_lines = []

    def __str__(self):
        return "{start_module}{name}\t{result}\n{lines_table}{end_module}".format(start_module=STR_MODULE_START,
                                                                                  name=self.name, result=self.result,
                                                                                  lines_table="".join(self.raw_lines),
                                                                                  end_module=STR_MODULE_END)


class ObjFastQC(object):
    """A object represent the fastqc_data.txt in zip file, 
    it contains a list of ModuleFastQC object,which represent the qc module information . 
    
    """

    def __init__(self, file_name=""):
        if file_name:
            _logger.debug("parsing file : {name_this_file}".format(name_this_file=file_name))
            self.translate_from_str_or_bytes(_read_from(file_name))
        else:
            self.order_of_modules = ""

    def translate_from_str_or_bytes(self, fastq_report_content):
        if isinstance(fastq_report_content, bytes):
            _logger.debug("binary report encountered")
            fastq_report_lines = fastq_report_content.decode().split("\n")
        elif isinstance(fastq_report_content, str):
            _logger.debug("text report encountered")
            fastq_report_lines = fastq_report_content.split("\n")
        else:
            _logger.error("{type_report} for ObjFastQC ...".format(type_report=str(type(fastq_report_content))))
            raise TypeError("un-known type given to fastqc object")

        modules = _transform_str_lines_to_fastqc_obj(fastq_report_lines)

        _logger.debug("there is {num_modules} modules in all ".format(num_modules=len(modules)))

        self.__update_module_info(modules)

    def __update_module_info(self, modules):
        module_names_in_order = [x.name.strip() for x in modules]
        self.order_of_modules = module_names_in_order
        self.__dict__.update(dict(zip(module_names_in_order, modules)))


def _transform_str_lines_to_fastqc_obj(content):
    flag_in_module = False
    modules = []

    for line in content:
        if flag_in_module:
            if line.strip() == STR_MODULE_END:  # end of module
                flag_in_module = False
                # dump the module
                modules.append(current_module)
            else:  # normal module line
                current_module.raw_lines.append(line)
        else:
            if line.strip().startswith(">>"):  # start module
                current_module = ModuleFastQC()
                current_module.name, current_module.result = line.strip().strip(">").split("\t")
                flag_in_module = True
            else:
                if line.strip().startswith("#"):
                    pass  # just ignore the header line

    return modules
